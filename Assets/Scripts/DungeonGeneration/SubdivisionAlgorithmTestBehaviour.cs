/*
 * TDS(c) 2018 by Another Pointless Pun
 * TDS is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.
 * You should have received a copy of the license along with this work.If not, see<http://creativecommons.org/licenses/by-sa/4.0/>.
 */

namespace Tds.DungeonGeneration
{
    using System.Collections.Generic;
    using UnityEngine;

    /// <summary>
    /// Behaviour providing an interface to define and test level generation
    /// </summary>
    public class SubdivisionAlgorithmTestBehaviour : MonoBehaviour
    {
        /// <summary>
        /// Algorithm which will randomly split up a rectangle in subrectangles
        /// </summary>
        public SubdivisionAlgorithm _rectSubdivisionAlgorithm = new SubdivisionAlgorithm();

        /// <summary>
        /// Algorith which will randomly traverse a path throught the split up rectangles
        /// generated by the subdivision algorithm
        /// </summary>
        public SplitRectTraversalAlgorithm _traversalAlgorithm = new SplitRectTraversalAlgorithm();

        /// <summary>
        /// Prefab for the debug object
        /// </summary>
        public GameObject _rectDebugPrefab;

        /// <summary>
        /// Colors used to color the maze in
        /// </summary>
        public Color[] _rectColors = new Color[] { Color.white, Color.yellow, Color.cyan, Color.blue, Color.green, Color.red };

        /// <summary>
        /// Width of the initial rect which will be subdivided
        /// </summary>
        public int _width = 20;

        /// <summary>
        /// Height of the initial rect which will be subdivided
        /// </summary>
        public int _height = 20;

        /// <summary>
        /// Custom multiplier to scale the debug objects to suitable proportions
        /// </summary>
        public float _scaleMultiplier = 3;

        /// <summary>
        /// Flag indicating the traversal algorithm should be used
        /// </summary>
        public bool _traversePath = false;
        
        /// <summary>
        /// Cached list of debug objects
        /// </summary>
        private List<GameObject> _debugObjects = new List<GameObject>();

        /// <summary>
        /// Creates a level, is called from the SubdivisionAlgorithmInspector
        /// </summary>
        public void BuildLevel()
        {
            ClearDebugObjects();

            var subdivisions = _rectSubdivisionAlgorithm.Subdivide(new SplitRect(0, 0, _width, _height));

            if (_traversePath)
            {
                var traversalRoot = _traversalAlgorithm.TraverseSplitRects(subdivisions);
                CreateTraversalNodeDebugObjects(traversalRoot, 0, new Vector3(-_width * 0.5f, -_height * 0.5f, 0));
            }
            else
            {
                CreateSplitRectDebugObjects(subdivisions);
            }
        }

        /// <summary>
        /// Clear all debug objects
        /// </summary>
        public void ClearDebugObjects()
        {
            if (Application.isEditor)
            {
                _debugObjects.ForEach(obj => DestroyImmediate(obj));
            }
            else
            {
                _debugObjects.ForEach(obj => Destroy(obj));
            }

            _debugObjects.Clear();
        }

        /// <summary>
        /// Create the rectangles making up the travelsal tree
        /// </summary>
        /// <param name="root"></param>
        /// <param name="colorIndex"></param>
        /// <param name="offset"></param>
        private void CreateTraversalNodeDebugObjects(TraversalNode root, int colorIndex, Vector3 offset)
        {
            if (root != null)
            {
                var debugObject = CreatDebugVisual(root._split._rect, offset, colorIndex);
                var debugBehaviour = debugObject.AddComponent<TraversalNodeDebugBehaviour>();

                debugObject.transform.parent = gameObject.transform;

                debugBehaviour._node = root;
                debugBehaviour._scale = _scaleMultiplier;
                debugBehaviour._offset = offset;

                root.DebugElement = debugObject;

                _debugObjects.Add(debugObject);

                for (int i = 0; i < root._children.Count; ++i)
                {
                    CreateTraversalNodeDebugObjects(root._children[i], ++colorIndex, offset);
                    colorIndex++;
                }
            }
        }

        /// <summary>
        /// Create the debug objects for the split rect
        /// </summary>
        /// <param name="splitRectangles"></param>
        private void CreateSplitRectDebugObjects(List<SplitRect> splitRectangles)
        {
            var colorIndex = 0;
            var offset = new Vector3(-_width * 0.5f, -_height * 0.5f, 0);

            splitRectangles.ForEach((split) =>
            {
                var debugObject = CreatDebugVisual(split._rect, offset, colorIndex);

                debugObject.transform.parent = gameObject.transform;
                debugObject.AddComponent<SplitRectDebugBehaviour>()._rect = split;
                split.DebugElement = debugObject;
                _debugObjects.Add(debugObject);

                colorIndex++;
            });
        }

        /// <summary>
        /// Instantiate a debug prefab
        /// </summary>
        /// <param name="rect"></param>
        /// <param name="offset"></param>
        /// <param name="colorIndex"></param>
        /// <returns></returns>
        private GameObject CreatDebugVisual(RectInt rect, Vector3 offset, int colorIndex)
        {
            var debugObject = Instantiate(_rectDebugPrefab);


            debugObject.name = "splitrect: " + rect;

            debugObject.transform.position = new Vector3(rect.position.x + 0.5f * rect.width
                                                   , rect.position.y + 0.5f * rect.height
                                                   , 0) + offset;

            debugObject.transform.localScale = new Vector3(rect.width * _scaleMultiplier
                                                    , rect.height * _scaleMultiplier, 1);

            debugObject.GetComponent<SpriteRenderer>().color = _rectColors[colorIndex % _rectColors.Length];

            return debugObject;
        }

    }
}
